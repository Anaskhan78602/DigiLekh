import {
  i
} from "./chunk-PVUZUJ4L.js";
import {
  require_react
} from "./chunk-I773Y2XN.js";
import {
  __toESM
} from "./chunk-LK32TJAX.js";

// node_modules/react-typed/dist/mjs/index.js
var import_react = __toESM(require_react());
var ReactTyped = (0, import_react.memo)(({ style, className, typedRef, parseRef: transformRef, stopped, children, startWhenVisible, ...typedOptions }) => {
  const rootElement = (0, import_react.useRef)(null);
  const shouldUpdateArgs = (0, import_react.useMemo)(() => {
    var _a;
    return [
      ...Object.values(typedOptions).filter((v) => typeof v === "boolean" || typeof v === "number" || typeof v === "string"),
      (_a = typedOptions.strings) == null ? void 0 : _a.join(",")
    ];
  }, [typedOptions]);
  (0, import_react.useEffect)(() => {
    const element = transformRef && transformRef(rootElement) || rootElement.current;
    const typed = new i(element, { ...typedOptions });
    if (stopped || startWhenVisible) {
      typed == null ? void 0 : typed.stop();
    }
    if (startWhenVisible) {
      const observer = new IntersectionObserver(([entry]) => {
        if (entry.isIntersecting) {
          typed == null ? void 0 : typed.start();
          observer.disconnect();
        }
      });
      observer.observe(element);
    }
    if (typedRef && typed) {
      typedRef(typed);
    }
    return () => {
      typed.destroy();
    };
  }, shouldUpdateArgs);
  const child = !children ? import_react.default.createElement("span", { style, ref: rootElement }) : import_react.default.cloneElement(children, {
    ref: rootElement
  });
  return import_react.default.createElement("span", { style, className, "data-testid": "react-typed" }, child);
});
export {
  ReactTyped,
  i as Typed
};
//# sourceMappingURL=react-typed.js.map
